<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>string 객체</title>
</head>
<body>
    
</body>
<script>
//string  객체 생성
let str = "";         //string wrapper class
let strObj = new String("string");  //string object

document.write(`<h2>charAt 함수<h2>`);
//1.charAt()함수
//string에서 전달받은 인덱스 위치한 문자나 문자 코드를 반환한다.
const str1 = "Javascript";
document.write(`0번째 인덱스 :${str1.charAt(0)}<br>`);
document.write(`5번째 인덱스 :${str1.charAt(5)}`);
document.write(`<hr>`);


//2.charCodeAt()함수
//string에서 전달받은 인덱스에 위치한 문자를 유니코드값으로 변환한다.
document.write(`<h2>charCodeAt() 함수</h2>`)
document.write(`<h3>0번째 인덱스의 유니코드값 :${str1.charCodeAt(0)}</h3><br>`);
document.write(`<hr>`);


//3.indexDf()함수
//string에서 특정 문자나 문자열이 처음으로 등장하는 위치를 반환한다.
document.write(`<h2>indexOf() 함수</h2>`)
const str2 = "abcDefabc";
document.write(`<h3>abc가 시작되는 인덱스 : ${str2.indexOf("abc")}</h3>`);
//문자열을 비교할때 문자의 대소문자를 구분한다.
document.write(`<h3>인덱스 3부터 abc 가 시작되는 인덱스 : ${str2.indexOf("abc",3)}</h3>`);
document.write(`<hr>`);


//4.lastIndexOf()함수
//string에서 특정 뮨자나 문자열이 마지막으로 등장하는 위치(인덱스)를 반환한다.
document.write(`<h2>lastIndexOf() 함수</h2>`)
document.write(`<h3>abc가 마지막으로 시작되는 인덱스 : ${str2.lastIndexOf("abc")}</h3>`);
document.write(`<hr>`);



//5.concat() 함수
//string에 전달받은 문자열을 결합한 새로운 문자열을 반환한다.
document.write(`<h2>concat() 함수</h2>`)
const str3 = "Javascript";
document.write(`<h3>concat으로 문자열 결합 : ${str3.concat("abc")}</h3>`);
document.write(`<h3>concat으로 문자열 결합 : ${str3.concat(" abc"," and usefull!!")}</h3>`);
document.write(`<hr>`);



//6.trim()함수
//string 의 양 끝에 존재하는 모든 공백과 줄 바꿈 문자를 제거한 새로운 문자열을 반환한다.
document.write(`<h2>trim() 함수</h2>`)
const str4 = "           J a v a s c r i p t";
document.write(`<h3>trim으로 공백 제거 : ${str4.trim()}</h3>`);
document.write(`<hr>`);



//6.replace()함수
//string 에서 인수로 전달받은 정규 표현식을 이용하여 string의 대체작업을 수행한다.
document.write(`<h2>replace() 함수</h2>`)
const str5 = "javascript is awesome"
document.write(`<h3>is를 공백으로 대체 : ${str5.replace("is","")}</h3>`);
document.write(`<h3>s를 *으로 대체 : ${str5.replace("s","*")}</h3>`);
document.write(`<h3>s를 *으로 대체 : ${str5.replace(/s/gi,"*")}</h3>`);
document.write(`<hr>`);


//**정규표현식**
//문자열에서 특정한 규칙을 갖는 문자열의 집합을 찾아내기 위한 검색 패턴이다.
//문법: /검색패턴/플래그
//플래그:
//i- 검색 패턴을 비교할 때 대소문자를 구분하지 않도록 설정
//g- 검색 패턴을 비교할 때 일치하는 모든 부분을 선택하도록 설정
//m- 검색 패턴을 비교할 떄 여러줄의 문자열을 그대로 여러줄로 비교히도록 설정
//y- 대상 문자열의 현재 위치부터 비교를 시작하도록 설정

//특수문자(검색패턴으로 들어갈 수 있는)
//단순한 패턴을 검색하고자 할 때는 찾고자 하는 문자열을 직접 나열하면 된다.
//숫자만을 검색하거나, 띄어쓰기, 특수문자 등을 검색하려면 검색패턴으로 특정한 특수문자를 사용해야 한다.
// \ :역슬래시 다음에 일반 문자가 나오면 이스케이프 문자로 해석하고, 특수문자가 나오면 일반 문자로 해석
// \d : 숫자를 검색 == /[0-9]/
// \D : 숫자가 아닌 문자를 검색 == /[^0-9]/
// \w : 언더바(_)를 포함한 영문자 및 숫자를 검색 ==/[A-Za-z0-9_]/
// \W : 언더바(_), 영문자, 숫자가 아닌 문자를 검색 == /[^A-Za-z0-9_]/
// \s : 띄어쓰기, 탭, 줄바꿈 문자 등의 공백 문자를 검색
// \S : 띄어쓰기, 탭, 줄바꿈 문자 등의 공백 문자가 아닌 문자를 검색
// \b : 단어의 맨 앞이나 맨 뒤가 패턴과 일치하는지를 검색


// 전화번호 검색패턴 (예 : 000-0000-0000 => /[0-9]{3}-[0-9]{4}-[0-9]{4}/
// 이메일 검색패턴 (예 : 0000@0000.000 => /[0-9a-zA-Z]+@[a-z]+\.[a-z\.]{3,}/
let reg = /[0-9a-zA-Z]+@[a-z]+\.[a-z\.]{3,}/;
const email = "rjeh321@naver.com";
console.log(reg.test(email));



//8.search()함수
//string 에서 인수로 전달받은 정규 표현식 또는 문자열을 이용하여 string의 검색 작업을 수행한다.
document.write(`<h2>search() 함수</h2>`)
document.write(`<h3>is 검색 : ${str5.search("is")}</h3>`);
document.write(`<h3>s 검색 : ${str5.search("s")}</h3>`);
document.write(`<h3>s 검색 : ${str5.search(/s/)}</h3>`);
document.write(`<hr>`);



//9.match()함수
//정규식 혹은 문자열로 검색하여 일치하는 결과를 배열로 리턴한다. 발견되지 않으면 null을 리턴한다.
document.write(`<h2>match() 함수</h2>`)
document.write(`<h3>match로 java 확인 : ${str5.match("java")}</h3>`);
const strTest = str5.match("java");
document.write(`<hr>`);



//10.substring()함수
//string에서 전달받은 시작 인덱스부터 종료 인덱스 바로 앞까지의 문자열을 추출한 새로운 문자열을 반환한다.
//abcDefabc
document.write(`<h2>substring() 함수</h2>`)
document.write(`<h3>substring(2,6) : ${str2.substring(2,6)}</h3>`);
document.write(`<h3>substring(2) : ${str2.substring(2)}</h3>`);
document.write(`<hr>`);




//11.substr()함수
//string에서 전달받은 시작 인덱스 부터 길이만큼의 문자열울 추출한 새로운 문자열을 반환한다.
//abcDefabc
document.write(`<h2>substr() 함수</h2>`)
document.write(`<h3>substr(2,6) : ${str2.substr(2,6)}</h3>`);
document.write(`<hr>`);



//12.slice()함수
// ['javascript', 'java', 'html', 'css'].slice(1, 3) == ['java', 'html']
//string에서 전달받은 시작 인덱스 부터 종료 인덱스 바로 앞까지의 문자열울 추출한 새로운 문자열을 반환한다.
//abcDefabc
document.write(`<h2>slice() 함수</h2>`)
document.write(`<h3>slice(2,6) : ${str2.slice(2,6)}</h3>`);
//substring은 음수가 전달되면 0으로 변경해서 함수를 실행한다
document.write(`<h3>slice(-4,-2) : ${str2.slice(-4,2)}</h3>`);
document.write(`<h3>substring(-4,-2) : ${str2.substring(-4,2)}</h3>`);
//substring은 시작값이 종료값보다 클 경우 서로 교환해서 함수를 실행한다.
document.write(`<h3>slice(4,2) : ${str2.slice(4,2)}</h3>`);
document.write(`<h3>substring(4,2) : ${str2.substring(4,2)}</h3>`);
document.write(`<hr>`);




//13.split()함수
//string을 구분자 기준으로 나뉜 후에 나뉜 문자열을 배열로 반환한다.
document.write(`<h2>split() 함수</h2>`)
const str6 = "사과/바나나/파인애플/딸기/포도";
document.write(`<h3>split 사용 : ${str6.split("/")}</h3>`);
console.log(str6.split("/"));






















document.write("<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>")
</script>
</html>